package main
// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates contributors.go. It can be invoked by running
// go generate

import (
	//"bufio"
	"bytes"
	"fmt"
	//"strings"
	"encoding/csv"
	"io/ioutil"

	//"fmt"
	"io"
	"reflect"
	"strconv"
	"time"

	//"io"
	"log"

	//"strings"
	//"text/template"
	//"time"
	//"io/ioutil"
)


type ret struct {
	V   CompanyListing
	Err error
}

// parse a csv file and return an array of resources
func parse(r io.Reader) chan ret {
	c := make(chan ret, 0)
	go func() {
		defer close(c)
		rd := csv.NewReader(r)
		rd.Comma = rune('|')
		var header []string
		header, err := rd.Read()
		if err != nil {
			c <- ret{CompanyListing{}, err}
		}

		e := CompanyListing{}
		et := reflect.TypeOf(e)
		var headers = make(map[string]int, et.NumField())
		for i := 0; i < et.NumField(); i++ {
			headers[et.Field(i).Name] = func(element string, array []string) int {
				for k, v := range array {
					if v == element {
						return k
					}
				}
				return -1
			}(et.Field(i).Tag.Get("csv"), header)
		}
		for {
			var e = CompanyListing{}
			record, err := rd.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				c <- ret{CompanyListing{}, err}
			}
			for h, i := range headers {
				if i == -1 {
					continue
				}
				elem := reflect.ValueOf(&e).Elem()
				field := elem.FieldByName(h)
				if field.CanSet() {
					switch field.Type().Name() {
					case "float64":
						a, _ := strconv.ParseFloat(record[i], 64)
						field.Set(reflect.ValueOf(a))
					case "Time":
						a, _ := time.Parse("2006-01-02T00:00:00Z", record[i])
						field.Set(reflect.ValueOf(a))
					default:
						field.Set(reflect.ValueOf(record[i]))
					}
				}
			}
			c <- ret{e, nil}
		}
	}()
	return c
}

// test holds a structure
type CompanyListing struct {
	Symbol   string `csv:"Symbol"`
	SecurityName  string `csv:"Security Name"`
	MarketCategory string `csv:"Market Category"`
	TestIssue string `csv:"Test Issue"`
	FinancialStatus string `csv:"Financial Status"`
	RoundLotSize string `csv:"Round Lot Size"`
	ETF string `csv:"ETF"`
	NextShares string `csv:"NextShares"`
}
// Symbol|Security Name|Market Category|Test Issue|Financial Status|Round Lot Size|ETF|NextShares
func main() {
	var (
		listings []CompanyListing
		err      error
		data     []byte
	)
	// Open the file
	if data, err = ioutil.ReadFile("nasdaq-data/nasdaqlisted.txt"); err != nil {
		log.Fatalln("Couldn't open the csv file", err)
	}
	// Parse the file
	a := bytes.NewReader(data)
	parsed := parse(a)
	for item := range parsed {
		listings = append(listings, item.V)
	}
	for i, obj := range listings {
		fmt.Printf("idx: %d\n", i)
		fmt.Printf("obj: %v\n", obj)
	}

}


//	f, err := os.Create("contributors.go")
//	die(err)
//	defer f.Close()
//
//	packageTemplate.Execute(f, struct {
//		Timestamp time.Time
//		URL       string
//		Carls     []string
//	}{
//		Timestamp: time.Now(),
//		URL:       url,
//		Carls:     carls,
//	})
//}

//func die(err error) {
//	if err != nil {
//		log.Fatal(err)
//	}
//}

/*
var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from
// {{ .URL }}
package tickers

var Contributors = []string{
{{- range .Carls }}
	{{ printf "%q" . }},
{{- end }}
}
`))

*/
